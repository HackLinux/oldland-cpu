<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Oldland-cpu : Oldland CPU - a 32-bit RISC FPGA CPU including RTL + tools" />

    <link rel="stylesheet" type="text/css" media="screen" href="..//stylesheets/stylesheet.css">

    <title>Oldland-cpu</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/jamieiles/oldland-cpu">View on GitHub</a>

          <h1 id="project_title"></h1>
          <h2 id="project_tagline">Oldland CPU - a 32-bit RISC FPGA CPU including RTL + tools</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/jamieiles/oldland-cpu/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/jamieiles/oldland-cpu/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">

<h1 id="oldland_cpu">Oldland CPU</h1>

<h2 id="architecture">Architecture</h2>

<ul>
<li>13x32-bit GPR’s.</li>

<li>1x32-bit frame pointer, addressable as FP</li>

<li>1x32-bit link register, addressable as LR.</li>

<li>1x32-bit stack pointer, addressable as SP.</li>

<li>1x32-bit status register:
<ul>
<li>Interrupt enable flag</li>

<li>Negative flag</li>

<li>Overflow flag</li>

<li>Carry flag</li>

<li>Zero flag</li>
</ul>
</li>
</ul>

<p>Everything is little endian.</p>

<p>Arithmetic/bitwise instructions:</p>

<ul>
<li>ADD, SUB,</li>

<li>LSL, LSR, ORR, AND, XOR, BIC</li>

<li>Rd := Ra OP Rb or:</li>

<li>Rd := Ra OP #imm</li>

<li>CMP Ra, Rb</li>
</ul>

<p>Branch instructions:</p>

<ul>
<li>B #offs := PC += #offs</li>

<li>BEQ #offs := if Z: PC += #offs</li>

<li>BNE #offs := if Z: PC += #offs</li>

<li>BGT #offs := if !Z: PC += #offs</li>

<li>CALL #offs # Like branch, but stores the return address in R6.</li>

<li>RET # return from CALL</li>
</ul>

<p>Load/Store instructions:</p>

<ul>
<li>LDR Rd, Ra, #idx := Rd = M[Ra + idx]<br />e.g. LDR R1, [R2, #0x20] means load the contents of M[R2 + 0x20] into R1</li>

<li>STR Ra, #idx, Rb := M[Ra + idx] = Rb</li>

<li>LDR16, LDR8, STR16, STR8 : 8 + 16 bit versions. <br />e.g. STR R1, [R2, #0x20] means store the contents of R1 into M[R2 + 0x20]</li>

<li>MOVHI Rd, #imm: Rd[31:16] := imm</li>
</ul>

<p>Example assembly:</p>

<pre><code>  add		$r0, r0, #1
  ldr		$r1, dataval
  movhi		$r2, $hi(vtable)
  add		$r2, r2, $lo(vtable)
  call		0x100
  call		myfunc

dataval:
  .word		0xdeadbeef

myfunc:
  str8		$r2, [$r0, 0x0]
  str		$r1, [$r0, 0x4]
  ret</code></pre>

<h2 id="encoding">ENCODING</h2>

<p>For ALU operations, if R is set then rd := ra OP Rb else rd := ra OP I For branch operations, if R is set then PC := Ra else PC += I For load, if R, Rd := M[Ra + I] else Rd := M[PC + I] For store, if R, M[Ra + I] := rb, else M[PC + I] := rb</p>

<p>Encoding:</p>

<pre><code>	31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00

ADD	 0  0  0  0  0  0  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb rd rd rd rd
ADDC	 0  0  0  0  0  1  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb rd rd rd rd
SUd	 0  0  0  0  1  0  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb rd rd rd rd
SUdC	 0  0  0  0  1  1  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb rd rd rd rd
LSL	 0  0  0  1  0  0  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb rd rd rd rd
LSR	 0  0  0  1  0  1  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb rd rd rd rd
AND	 0  0  0  1  1  0  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb rd rd rd rd
XOR	 0  0  0  1  1  1  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb rd rd rd rd
BIC	 0  0  1  0  0  0  R  0  0  0  0  0  0  0  0  0  0  I  I  0 ra ra ra ra rb rb rb rb rd rd rd rd
BST	 0  0  1  0  0  1  R  0  0  0  0  0  0  0  0  0  0  I  I  0 ra ra ra ra rb rb rb rb rd rd rd rd
OR 	 0  0  1  0  1  0  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb rd rd rd rd
CMP	 0  0  1  1  0  0  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb  x  x  x  x
ASR 	 0  0  1  1  1  0  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb rd rd rd rd

CALL	 0  1  0  0  0  0  R  x  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I IR IR IR IR
RET	 0  1  0  0  0  1  1  x  x  x  x  x  x  x  x  x  x  x  x  x  1  1  1  0  x  x  x  x  x  x  x  x
RFE	 0  1  0  0  1  0  0  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x
B	 0  1  0  1  0  0  R  x  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I IR IR IR IR
BNE	 0  1  0  1  0  1  R  x  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I IR IR IR IR
BEQ	 0  1  0  1  1  0  R  x  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I IR IR IR IR
BGT	 0  1  0  1  1  1  R  x  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I IR IR IR IR
BLT	 0  1  1  0  0  0  R  x  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I IR IR IR IR
BGTS	 0  1  1  0  0  1  R  x  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I IR IR IR IR
BLTS	 0  1  1  0  1  0  R  x  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I IR IR IR IR
SWI	 0  1  1  1  1  1  0  I  I  I  I  I  I  I  I  I  I  I  I  I  x  x  x  x  x  x  x  x  x  x  x  x

LDR	 1  0  0  0  0  0  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra  x  x  x  x rd rd rd rd
LDR16	 1  0  0  0  0  1  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra  x  x  x  x rd rd rd rd
LDR8	 1  0  0  0  1  0  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra  x  x  x  x rd rd rd rd

STR	 1  0  0  1  0  0  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb  x  x  x  x
STR16	 1  0  0  1  0  1  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb  x  x  x  x
STR8	 1  0  0  1  1  0  R  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra rb rb rb rb  x  x  x  x

BKP	 1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  x  x  x  x  x  x  x  x  x  x  x  x
GCR	 1  1  0  0  0  1  0  I  I  I  I  I  I  I  I  I  I  I  I  I  x  x  x  x  x  x  x  x rd rd rd rd
SCR	 1  1  0  0  1  0  0  I  I  I  I  I  I  I  I  I  I  I  I  I ra ra ra ra  x  x  x  x  x  x  x  x
MOVHI	 1  1  1  0  1  1  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  0  x  x  x  x  x rd rd rd rd
ORLO	 1  1  1  1  0  1  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  I  0  x rb rb rb rb rd rd rd rd
CPUID	 1  1  0  1  1  1  0  I  I  I  I  I  I  I  I  I  I  I  I  I  x  x  x  x  x  x  x  x rd rd rd rd
NOP	 1  1  1  1  1  1  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x  x</code></pre>

<h2 id="relocations">RELOCATIONS</h2>

<ul>
<li>R_OLDLAND_NONE:
<ul>
<li>NOP</li>
</ul>
</li>

<li>R_OLDLAND_32:
<ul>
<li>32-bit absolute relocation:</li>
</ul>
</li>

<li>R_OLDLAND_PC24:
<ul>
<li>24-bit PC-relative relocation for branches.</li>
</ul>
</li>

<li>R_OLDLAND_PC16:
<ul>
<li>16-bit PC-relative relocation for load/store.</li>
</ul>
</li>

<li>R_OLDLAND_HI16:
<ul>
<li>16-bit absolute relocation for MOVHI.</li>
</ul>
</li>

<li>R_OLDLAND_LO16:
<ul>
<li>16-bit absolute relocation for ADD/OR.</li>
</ul>
</li>
</ul>

<h2 id="alu_operations">ALU operations</h2>

<ul>
<li>ra OP rb</li>

<li>ra OP imm13</li>

<li>pc OP imm24</li>

<li>pc OP imm13</li>

<li>pc OP rb</li>
</ul>

<h2 id="stalling">Stalling</h2>

<p>Branch target doesn’t get resolved until execute stage. Stall until PC is updated with branch target.</p>

<p>Memory accesses can take a variable number of cycles (cache misses/peripherals etc). Stall until access completed.</p>

<h2 id="exception_handling">Exception Handling</h2>

<p>Exception handlers are defined in a table of jumps to handlers:</p>

<p>0x00: reset 0x04: illegal instruction 0x08: software interrupt 0x0c: hardware interrupt 0x10: instruction fetch abort 0x14: data abort</p>

<p>The table must be aligned to a 64 byte boundary.</p>

<p>The address of the table is stored in control register 0, so to set the table:</p>

<pre><code>movhi	$r0, %hi(ex_table)
orlo	$r0, $r0, %lo(ex_table)
scr	0, $r0</code></pre>

<p>On exception entry the CPU enters the exception handling mode and stores the contents of the current mode PSR into the saved PSR control register. The fault address is stored in cr4 and the cpu jumps to the correct exception handler.</p>

<p>To return from the exception the RFE instruction restores the saved PSR from the saved registers and sets the PC to the faulting address (which can be modified in the exception handler).</p>

<p>$sp is banked between user/supervisor mode to make handling of exceptions more convenient and there are a pair of instructions for reading/writing the usermode $sp, only from supervisor mode. There are only 2 processor modes.</p>

<p>IRQ entry:</p>

<ul>
<li>discard instructions in fetch and decode stages</li>

<li>move current $sp into saved_sp</li>

<li>move current psr into saved_psr</li>

<li>store pc_plus_4 at execute stage into fault_address</li>

<li>disable irqs in psr</li>

<li>set branch enable and branch destination to the irq entry</li>
</ul>

<p>RFE implementation:</p>

<ul>
<li>discard instructions in fetch and decode stages.</li>

<li>move saved sp into $sp</li>

<li>moved saved_psr into psr</li>

<li>move fault_address into pc (handler should have adjusted it).</li>
</ul>

<p>Control registers:</p>

<ul>
<li>cr0: exception table base address
<ul>
<li>[31:6]: exception table base address[31:6]</li>

<li>[5:0]: reserved, SBZ</li>
</ul>
</li>

<li>cr1: PSR
<ul>
<li>[31:4]: reserved, SBZ</li>

<li>[5:5]: user mode</li>

<li>[4:4]: irqs enabled</li>

<li>[3:3]: negative flag</li>

<li>[2:2]: overflow flag</li>

<li>[1:1]: carry flag</li>

<li>[0:0]: zero flag</li>
</ul>
</li>

<li>cr2: saved PSR</li>

<li>cr3: fault address register</li>

<li>cr4: data fault address</li>
</ul>

<h2 id="cpuid_registers">CPUID registers</h2>

<p>The CPUID registers provide a mechanism for software to discover hardware features:</p>

<ul>
<li>0: CPU version
<ul>
<li>[31:16]: Vendor</li>

<li>[15:0]: Model</li>
</ul>
</li>

<li>1: CPU core speed
<ul>
<li>[31:0] core speed (Hz)</li>
</ul>
</li>

<li>2: Instruction set features
<ul>
<li>[31:0]: SBZ</li>
</ul>
</li>

<li>3: Instruction cache feature register
<ul>
<li>[31:24]: SBZ</li>

<li>[23:8]: number of cache lines</li>

<li>[7:0]: words per cache line</li>
</ul>
</li>

<li>4: Data cache feature register
<ul>
<li>[31:24]: SBZ</li>

<li>[23:8]: number of cache lines</li>

<li>[7:0]: words per cache line</li>
</ul>
</li>
</ul>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Oldland-cpu maintained by <a href="https://github.com/jamieiles">jamieiles</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-43848066-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>

